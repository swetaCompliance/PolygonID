import { Request, Response } from "express";
import { Model as MongoModel } from "mongoose";
import { ModelStatic as SequelizeModel} from 'sequelize'
import { Dialect } from "..";
import { FindResponse, InternalServiceMethods, MongoDBService, PostgreSQLService, Query, User } from './databases'

type ServiceType<T, U = Dialect> = 
  U extends 'postgres' 
    ? PostgreSQLService<T> 
      : U extends 'mongodb' 
      ? MongoDBService<T> 
      : any;

type ModelType<T, U> = 
      U extends 'postgres' 
        ? SequelizeModel<any>
        : U extends "mongodb" 
          ? MongoModel<T>
          : any

export interface IXitovServiceProps {
  Model: any;
  dialect?: Dialect;
  pagination?: boolean
}

export class XitkovService<T, U = 'postgres'> implements InternalServiceMethods<T> {
  private service: ServiceType<T, U>;
  private Model: ModelType<T, U>
  pagination?: boolean;

  constructor({Model, dialect, pagination}: IXitovServiceProps) {
    this.Model = Model;
    switch(dialect) {
      case 'postgres':
        this.service =  new PostgreSQLService({ Model, pagination }) as any;
        break;
      case 'mongodb': 
      default:
        this.service =  new MongoDBService({ Model }) as any;
    }
  }

  async find(query: Query, user?: any, req?: Request, res?: Response): Promise<FindResponse<T>> {
    return await this.service.find(query, user, req, res);
  }

  async get(id: string | null, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | null> {
    return await this.service.get(id, query, user, req, res);
  }

  async create(data: Partial<T> | Partial<T>[], query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[]> {
    return await this.service.create(data, query, user, req, res);
  }

  async update(id: string, data: T, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | null> {
    return await this.service.update(id, data, query, user, req, res);
  }

  async patch(id: string, data: Partial<T>, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[] | null> {
    return await this.service.patch(id, data, query, user, req, res);
  }
  
  async remove(id: string, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[] | null> {
    return await this.service.remove(id, query, user, req, res);
  }

  get model(): ModelType<T, U> {
    return this.Model
  }

  async _find(query: Query, user?: any, req?: Request, res?: Response): Promise<FindResponse<T>> {
    return await this.service.find(query, user, req, res);
  }

  async _get(id: string | null, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | null> {
    return await this.service.get(id, query, user, req, res);
  }

  async _create(data: Partial<T> | Partial<T>[], query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[]> {
    return await this.service.create(data, query, user, req, res);
  }

  async _update(id: string, data: T, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | null> {
    return await this.service.update(id, data, query, user, req, res);
  }

  async _patch(id: string, data: Partial<T>, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[] | null> {
    return await this.service.patch(id, data, query, user, req, res);
  }
  
  async _remove(id: string, query?: Query, user?: User, req?: Request, res?: Response): Promise<T | T[] | null> {
    return await this.service.remove(id, query, user, req, res);
  }
}

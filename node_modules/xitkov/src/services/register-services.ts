import type {Application, Request, Response} from 'express';
// eslint-disable-next-line node/no-unsupported-features/node-builtins
import {promises} from 'fs';
import path from 'path';
import {Router} from 'express';
import {Config, Dialect, IAuth, Logger, addQuerySupport} from '..';
import {PostgresInternalServiceOptions, MongoInternalServiceOptions} from '.';
import { BadRequest, Unauthorized } from '../errors';
import { AuthService } from './auth';

type Method = 'get' | 'post' | 'patch' | 'put' | 'delete';

type Functions = 'find' | 'get' | 'create' | 'update' | 'patch' | 'remove';

type InternalServiceOptions = (PostgresInternalServiceOptions | MongoInternalServiceOptions) & { dialect : Dialect };

interface Methods {
  method: Method;
  url: string;
  func: Functions;
}

async function validate(Validator: any, func: string, value: any) {
  const schema = await Validator[func]
  if (schema) {
    try {
      const schemaValue = await schema().validateAsync(value);
      return schemaValue;
    } catch (err: any) {
      new BadRequest(err.message)
    }
  }
}

async function hooks(Hooks: any, func: string, parameters: any[], methodName: string) {
  const allHooks = Hooks[func]

  allHooks?.forEach?.((hook: any) => {
    hook?.(...parameters, methodName)
  });
  return allHooks
}

function getJWTDecoded(accessToken: string) {
  try {
    const base64Url = accessToken.split('.')[1];
    const decoded = Buffer.from(base64Url, 'base64').toString()
    return JSON.parse(decoded)
  } catch(error) {
    Logger.error("getJWTDecoded", error)
    return {}
  }
}

export async function registerServices(app: Application, auth?: IAuth, database?: Config['database']) {
  if (require.main?.filename == undefined) {
    throw new Error("Please provide service path")
  }
  const appDir = path.dirname(require.main?.filename as string);
  const serviceDirPath = appDir + '/services';

  const servicesNames = (await promises.readdir(serviceDirPath)).filter(
    file => !/index.ts/.test(file)
  );

  const methods: Methods[] = [
    {
      method: 'get',
      url: '/',
      func: 'find',
    },
    {
      method: 'get',
      url: '/:id',
      func: 'get',
    },
    {
      method: 'post',
      url: '/',
      func: 'create',
    },
    {
      method: 'patch',
      url: '/:id',
      func: 'patch',
    },
    {
      method: 'put',
      url: '/:id',
      func: 'update',
    },
    {
      method: 'delete',
      url: '/:id',
      func: 'remove',
    },
  ];

  const services: {[serviceName: string]: any} = {}

  for (const serviceName of servicesNames) {
    const servicePath = `${serviceDirPath}/${serviceName}/service`;
    const modelPath = `${serviceDirPath}/${serviceName}/model`;
    const validatorPath = `${serviceDirPath}/${serviceName}/validator`;
    const hooksPath = `${serviceDirPath}/${serviceName}/hooks`;
    let Model = null
    let Validator: any = null
    let Hooks: any = null
    try {
        if(database?.instance) {
          Model = (await import(modelPath)).default(database.instance);
        } else {
          Model = (await import(modelPath)).default;
        }
    } catch(err) {
        //
    }

    try {
      Validator = new (await import(validatorPath)).default;
    } catch(err) {
        //
    }

    try {
      Hooks = new (await import(hooksPath)).default;
    } catch(err) {
        //
    }
    const serviceConfig: Partial<InternalServiceOptions> = {}
   
    if (Model) {
      serviceConfig.Model = Model
    }
    serviceConfig.dialect = database?.dialect ?? 'mongodb'

    const service = new (await import(servicePath)).default(serviceConfig);
    services[serviceName] = service
    const router = Router();
    for (const {method, url, func} of methods) {
      const callback = async (req: Request, res: Response) => {
        const { required, baseURL } = auth ?? {}
        const {params, query, body, baseUrl, ...rest} = req;

        try {
          if (service.auth !== false) {
            // TODO: Temp will find the better solution later
            if (req.headers['internaltoken'] !== (process.env.INTERNAL_TOKEN ?? 'internal_token')) {
              if (required && baseURL) {
                const authorization = req.headers['authorization']
                if (!authorization) {
                  return new Unauthorized("You don't have permission")
                }

                const authService = new AuthService({ 
                  baseURL: baseURL, 
                  axiosConfig: {
                    headers: {
                      Authorization: authorization
                    }
                  }
                })

                const authData = await authService.verify()
                const {businessId} = authData ?? {}
                const decodedAccessToken = getJWTDecoded(authorization);
                const { business } = decodedAccessToken;
                const userBusinessId = businessId ?? business
                if (!userBusinessId) {
                  return new Unauthorized("You don't have permission")
                }
              
                const userData = ((req as any).user ?? {});
                (req as any).user = { ...userData, userBusinessId }
              }
            }
          }
          
          const user = (req as any).user
          const {id} = params;
          let parameters: any[] = [];
          let validatorValue
          switch (func) {
            case 'find':
              parameters = [query, user, req];
              validatorValue = query
              break;
            case 'get':
              parameters = [id, query, user, req];
              validatorValue = query
              break;
            case 'create':
              parameters = [body, query, user, req];
              validatorValue = body
              break;
            case 'patch':
              parameters = [id, body, query, user, req];
              validatorValue = body
              break;
            case 'update':
              parameters = [id, body, query, user, req];
              validatorValue = body
              break;
            case 'remove':
              parameters = [id, query, user, req];
              validatorValue = query
              break;
          }
          if (Hooks) {
            await hooks(Hooks, 'all', parameters, func)
            await hooks(Hooks, func, parameters, func)
            if (service.filtering !== false && func === 'find') {
              const updatedQuery = addQuerySupport(...parameters)
              parameters[0] = updatedQuery
            }
          }

          if(service[func] == undefined) {
            return res.status(404).send({
              message: "Not found"
            });
          }
          if (Validator) {
            await validate(Validator, func, validatorValue)
          }

          const response = await service[func](...parameters)
          let data = response

          if (Array.isArray(response)) {
            data = response
          }
          let count = undefined
          if (func === 'find' && data?.count && data.rows) {
            count = data.count
            delete data.count
            data = data.rows
          }
          else if(response == null) {
            if (id) {
              return res.status(400).send({message: `No record found for ${id}`});
            }
            return res.status(400).send({message: 'Bad Request'});
          }
          
          return res.send({
            message: "ok",
            data,
            count
          });
        } catch (error: any) {
          console.log("Error", {
            baseUrl,
            url,
            error,
          })
          Logger.error('Error', {
            baseUrl,
            url,
            error,
            message: error?.messsage
          });
          if (error instanceof Error) {
            return res.status(500).send({message: 'Something went wrong'});
          }
          if (typeof error === 'object') {
            return res.status(error.status).send({message: error.message});
          }
          return res.status(500).send({message: 'Something went wrong'});
        }
      };
      router[method](url, callback);
    }
    app.set('services', services)

    app.use(`/${serviceName}`, router);
  }
  return services;
}

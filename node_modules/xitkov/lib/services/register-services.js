"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerServices = void 0;
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const express_1 = require("express");
const __1 = require("..");
const errors_1 = require("../errors");
const auth_1 = require("./auth");
async function validate(Validator, func, value) {
    const schema = await Validator[func];
    if (schema) {
        try {
            const schemaValue = await schema().validateAsync(value);
            return schemaValue;
        }
        catch (err) {
            new errors_1.BadRequest(err.message);
        }
    }
}
async function hooks(Hooks, func, parameters, methodName) {
    var _a;
    const allHooks = Hooks[func];
    (_a = allHooks === null || allHooks === void 0 ? void 0 : allHooks.forEach) === null || _a === void 0 ? void 0 : _a.call(allHooks, (hook) => {
        hook === null || hook === void 0 ? void 0 : hook(...parameters, methodName);
    });
    return allHooks;
}
function getJWTDecoded(accessToken) {
    try {
        const base64Url = accessToken.split('.')[1];
        const decoded = Buffer.from(base64Url, 'base64').toString();
        return JSON.parse(decoded);
    }
    catch (error) {
        __1.Logger.error("getJWTDecoded", error);
        return {};
    }
}
async function registerServices(app, auth, database) {
    var _a, _b, _c;
    if (((_a = require.main) === null || _a === void 0 ? void 0 : _a.filename) == undefined) {
        throw new Error("Please provide service path");
    }
    const appDir = path_1.default.dirname((_b = require.main) === null || _b === void 0 ? void 0 : _b.filename);
    const serviceDirPath = appDir + '/services';
    const servicesNames = (await fs_1.promises.readdir(serviceDirPath)).filter(file => !/index.ts/.test(file));
    const methods = [
        {
            method: 'get',
            url: '/',
            func: 'find',
        },
        {
            method: 'get',
            url: '/:id',
            func: 'get',
        },
        {
            method: 'post',
            url: '/',
            func: 'create',
        },
        {
            method: 'patch',
            url: '/:id',
            func: 'patch',
        },
        {
            method: 'put',
            url: '/:id',
            func: 'update',
        },
        {
            method: 'delete',
            url: '/:id',
            func: 'remove',
        },
    ];
    const services = {};
    for (const serviceName of servicesNames) {
        const servicePath = `${serviceDirPath}/${serviceName}/service`;
        const modelPath = `${serviceDirPath}/${serviceName}/model`;
        const validatorPath = `${serviceDirPath}/${serviceName}/validator`;
        const hooksPath = `${serviceDirPath}/${serviceName}/hooks`;
        let Model = null;
        let Validator = null;
        let Hooks = null;
        try {
            if (database === null || database === void 0 ? void 0 : database.instance) {
                Model = (await Promise.resolve().then(() => __importStar(require(modelPath)))).default(database.instance);
            }
            else {
                Model = (await Promise.resolve().then(() => __importStar(require(modelPath)))).default;
            }
        }
        catch (err) {
            //
        }
        try {
            Validator = new (await Promise.resolve().then(() => __importStar(require(validatorPath)))).default;
        }
        catch (err) {
            //
        }
        try {
            Hooks = new (await Promise.resolve().then(() => __importStar(require(hooksPath)))).default;
        }
        catch (err) {
            //
        }
        const serviceConfig = {};
        if (Model) {
            serviceConfig.Model = Model;
        }
        serviceConfig.dialect = (_c = database === null || database === void 0 ? void 0 : database.dialect) !== null && _c !== void 0 ? _c : 'mongodb';
        const service = new (await Promise.resolve().then(() => __importStar(require(servicePath)))).default(serviceConfig);
        services[serviceName] = service;
        const router = express_1.Router();
        for (const { method, url, func } of methods) {
            const callback = async (req, res) => {
                var _a, _b;
                const { required, baseURL } = auth !== null && auth !== void 0 ? auth : {};
                const { params, query, body, baseUrl, ...rest } = req;
                try {
                    if (service.auth !== false) {
                        // TODO: Temp will find the better solution later
                        if (req.headers['internaltoken'] !== ((_a = process.env.INTERNAL_TOKEN) !== null && _a !== void 0 ? _a : 'internal_token')) {
                            if (required && baseURL) {
                                const authorization = req.headers['authorization'];
                                if (!authorization) {
                                    return new errors_1.Unauthorized("You don't have permission");
                                }
                                const authService = new auth_1.AuthService({
                                    baseURL: baseURL,
                                    axiosConfig: {
                                        headers: {
                                            Authorization: authorization
                                        }
                                    }
                                });
                                const authData = await authService.verify();
                                const { businessId } = authData !== null && authData !== void 0 ? authData : {};
                                const decodedAccessToken = getJWTDecoded(authorization);
                                const { business } = decodedAccessToken;
                                const userBusinessId = businessId !== null && businessId !== void 0 ? businessId : business;
                                if (!userBusinessId) {
                                    return new errors_1.Unauthorized("You don't have permission");
                                }
                                const userData = ((_b = req.user) !== null && _b !== void 0 ? _b : {});
                                req.user = { ...userData, userBusinessId };
                            }
                        }
                    }
                    const user = req.user;
                    const { id } = params;
                    let parameters = [];
                    let validatorValue;
                    switch (func) {
                        case 'find':
                            parameters = [query, user, req];
                            validatorValue = query;
                            break;
                        case 'get':
                            parameters = [id, query, user, req];
                            validatorValue = query;
                            break;
                        case 'create':
                            parameters = [body, query, user, req];
                            validatorValue = body;
                            break;
                        case 'patch':
                            parameters = [id, body, query, user, req];
                            validatorValue = body;
                            break;
                        case 'update':
                            parameters = [id, body, query, user, req];
                            validatorValue = body;
                            break;
                        case 'remove':
                            parameters = [id, query, user, req];
                            validatorValue = query;
                            break;
                    }
                    if (Hooks) {
                        await hooks(Hooks, 'all', parameters, func);
                        await hooks(Hooks, func, parameters, func);
                        if (service.filtering !== false && func === 'find') {
                            const updatedQuery = __1.addQuerySupport(...parameters);
                            parameters[0] = updatedQuery;
                        }
                    }
                    if (service[func] == undefined) {
                        return res.status(404).send({
                            message: "Not found"
                        });
                    }
                    if (Validator) {
                        await validate(Validator, func, validatorValue);
                    }
                    const response = await service[func](...parameters);
                    let data = response;
                    if (Array.isArray(response)) {
                        data = response;
                    }
                    let count = undefined;
                    if (func === 'find' && (data === null || data === void 0 ? void 0 : data.count) && data.rows) {
                        count = data.count;
                        delete data.count;
                        data = data.rows;
                    }
                    else if (response == null) {
                        if (id) {
                            return res.status(400).send({ message: `No record found for ${id}` });
                        }
                        return res.status(400).send({ message: 'Bad Request' });
                    }
                    return res.send({
                        message: "ok",
                        data,
                        count
                    });
                }
                catch (error) {
                    console.log("Error", {
                        baseUrl,
                        url,
                        error,
                    });
                    __1.Logger.error('Error', {
                        baseUrl,
                        url,
                        error,
                        message: error === null || error === void 0 ? void 0 : error.messsage
                    });
                    if (error instanceof Error) {
                        return res.status(500).send({ message: 'Something went wrong' });
                    }
                    if (typeof error === 'object') {
                        return res.status(error.status).send({ message: error.message });
                    }
                    return res.status(500).send({ message: 'Something went wrong' });
                }
            };
            router[method](url, callback);
        }
        app.set('services', services);
        app.use(`/${serviceName}`, router);
    }
    return services;
}
exports.registerServices = registerServices;
//# sourceMappingURL=register-services.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rootFromProof = exports.verifyProof = exports.siblignsFroomProof = void 0;
const bytes_1 = require("./bytes");
const hash_1 = require("../hash/hash");
const hash_2 = require("./hash");
const node_1 = require("./node");
const merkletree_1 = require("./merkletree");
const node_2 = require("../node/node");
const proof_1 = require("../errors/proof");
const siblignsFroomProof = (proof) => {
    let sibIdx = 0;
    const siblings = [];
    for (let i = 0; i < proof.depth; i += 1) {
        if ((0, bytes_1.testBitBigEndian)(proof.notEmpties, i)) {
            siblings.push(proof.siblings[sibIdx]);
            sibIdx += 1;
        }
        else {
            siblings.push(hash_1.ZERO_HASH);
        }
    }
    return siblings;
};
exports.siblignsFroomProof = siblignsFroomProof;
const verifyProof = async (rootKey, proof, k, v) => {
    try {
        const rFromProof = await (0, exports.rootFromProof)(proof, k, v);
        return (0, bytes_1.bytesEqual)(rootKey.value, rFromProof.value);
    }
    catch (err) {
        if (err === proof_1.ErrNodeAuxNonExistAgainstHIndex) {
            return false;
        }
        throw err;
    }
};
exports.verifyProof = verifyProof;
const rootFromProof = async (proof, k, v) => {
    const kHash = (0, hash_2.newHashFromBigInt)(k);
    const vHash = (0, hash_2.newHashFromBigInt)(v);
    let sibIdx = proof.siblings.length - 1;
    let midKey;
    if (proof.existence) {
        midKey = await (0, node_1.leafKey)(kHash, vHash);
    }
    else {
        if (typeof proof.nodeAux === 'undefined') {
            midKey = hash_1.ZERO_HASH;
        }
        else {
            const nodeAux = proof.nodeAux;
            if ((0, bytes_1.bytesEqual)(kHash.value, nodeAux.key.value)) {
                throw proof_1.ErrNodeAuxNonExistAgainstHIndex;
            }
            midKey = await (0, node_1.leafKey)(nodeAux.key, nodeAux.value);
        }
    }
    const path = (0, merkletree_1.getPath)(proof.depth, kHash.value);
    let siblingKey;
    for (let i = proof.depth - 1; i >= 0; i -= 1) {
        if ((0, bytes_1.testBitBigEndian)(proof.notEmpties, i)) {
            siblingKey = proof.siblings[sibIdx];
            sibIdx -= 1;
        }
        else {
            siblingKey = hash_1.ZERO_HASH;
        }
        if (path[i]) {
            midKey = await new node_2.NodeMiddle(siblingKey, midKey).getKey();
        }
        else {
            midKey = await new node_2.NodeMiddle(midKey, siblingKey).getKey();
        }
    }
    return midKey;
};
exports.rootFromProof = rootFromProof;
//# sourceMappingURL=proof.js.map
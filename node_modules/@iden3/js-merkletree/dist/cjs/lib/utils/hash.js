"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newHashFromString = exports.newHashFromHex = exports.newHashFromBigInt = void 0;
const crypto_1 = require("./crypto");
const hash_1 = require("../hash/hash");
const bigint_1 = require("./bigint");
const js_crypto_1 = require("@iden3/js-crypto");
const bytes_1 = require("./bytes");
// returned bytes endianess will be big-endian
const newHashFromBigInt = (bigNum) => {
    if (!(0, crypto_1.checkBigIntInField)(bigNum)) {
        throw 'NewBigIntFromHashBytes: Value not inside the Finite Field';
    }
    const bytes = (0, bigint_1.bigIntToUINT8Array)(bigNum);
    const hash = new hash_1.Hash();
    hash.value = bytes;
    return hash;
};
exports.newHashFromBigInt = newHashFromBigInt;
const newHashFromHex = (h) => {
    if (!h) {
        return hash_1.ZERO_HASH;
    }
    // TODO: add in field check
    const hash = new hash_1.Hash();
    hash.value = (0, bytes_1.swapEndianness)(js_crypto_1.Hex.decodeString(h));
    return hash;
};
exports.newHashFromHex = newHashFromHex;
// return object of class Hash from a decimal string
const newHashFromString = (decimalString) => {
    const bigNum = BigInt(decimalString);
    if (!(0, crypto_1.checkBigIntInField)(bigNum)) {
        throw 'NewBigIntFromHashBytes: Value not inside the Finite Field';
    }
    return (0, exports.newHashFromBigInt)(bigNum);
};
exports.newHashFromString = newHashFromString;
//# sourceMappingURL=hash.js.map